import autofit as af
from autofit.optimize.non_linear import multi_nest_output
import toy_gaussian as toy

# The aggregator allows us to load a set of results which were generated by running the same pipeline and phase.

# In 'runners/gaussian_x1.py', we fitted a Gaussian image with the pipelines, 'pipeline_initialize__gaussian_x1' and
# 'pipeline_main__gaussian_x1'. The results of this fit are in the 'output_fixed/gaussian_x1' folder.

# We can load all the results from any phase of this pipeline using the aggregator, enabling us to manipulate those
# results in Python to plotters figures, interpret results, check specific values, etc.

# To begin, we setup the path to the toy_gaussian_workspace and our output folder.
workspace_path = "/home/jammy/PycharmProjects/PyAuto/PyAutoToy/toy_gaussian/workspace/"
output_path = workspace_path + "output/"

# Now we'll ue this path to explicitly set the config path and output path.
af.conf.instance = af.conf.Config(
    config_path=workspace_path + "config", output_path=output_path
)

# To use the aggregator we have to supply it with the pipeline name we want to load results from and the phase name
# of that pipeline we want to load results from. Lets load the results of the pipeline's final phase.

output_folder = "gaussian_x1__x3_fits/"
pipeline_name = "pipeline_main__x1_gaussian"
phase_name = "phase_1__x1_gaussian_final"


#### BUG 1 - The pipeline meta should not contain all summed pipeline names. We should only have to specify one pipeline
#### name in order to return the results oof that pipeline. E.g. we should be able to use the pipeline_name variable above.

#### Alternative, if changing the pipeline_meta is a pain, we could make it so that the aggregator only looks for whether the
#### in input string is 'in' the pipeline meta variable. The phase_name is unique and thus ensures we can get the results
#### we want, however this would mean that we are required to input a phase name to extract results.

pipeline_meta = "pipeline_initialize__x1_gaussian + pipeline_main__x1_gaussian"


# First, we create an instance of the aggregator, which takes the output path as input, telling it where to load
# results from.

### FEATURE - it would be good if this printed summary information of the pipelines / phases found. For example:

### Aggregator has found the results of fits in the following 3 folders:

### Folder 1 - gaussian_x1__x3_fits/gaussian_x1__sigma_0.1
### Folder 2 - gaussian_x1__x3_fits/gaussian_x1__sigma_0.5
### Folder 3 - gaussian_x1__x3_fits/gaussian_x1__sigma_1.0

aggregator = af.Aggregator(directory=output_path + output_folder)

# We can create a list of the optimizer classes of every phase. When you make a phase in a pipeline, you are
# probably used to seeing the following line:

# optimizer_class=af.MultiNest

# This line is telling the Phase which non-linear optimizer to use, in this case MultiNest. Every optimizer is created
# as an instance of a class in Python, which has methods built-in allowing one to manipulate its results.


#### Bug 2 - following the refactor the MultiNest class and MultiNest output classes are separate. We want to use the
#### output class to manipulate results in this script. Below, I have to manually setup the output class, which si simple
#### but makes the aggregator API a bit clunky. Can we have a method 'aggregator.non_linear_output'?

optimizers = aggregator.optimizers_with(pipeline=pipeline_meta, phase=phase_name)
phases = aggregator.phases_with(pipeline=pipeline_meta, phase=phase_name)

non_linear_outputs = list(
    map(
        lambda out, phase: multi_nest_output.MultiNestOutput(
            model=phase.model, paths=out.paths
        ),
        optimizers,
        phases,
    )
)


# First, if we print the non_linear_outputs we'll see that we have a Python list of two non_linear_outputs. These are the non_linear_outputs
# of phase 1 of our main pipeline for the image we modeled.

# If we had modeled 100 images, we'd have 100 non_linear_outputs. Clearly, with that in mind, for the code below you should
# be thinking how important the aggregator in manipulating large lens simulated datasets.

print(non_linear_outputs)

# Whats particularly powerful is that every optimizer now acts as an interface to the MultiNest chains on the hard
# disk. This means we can use the non_linear_outputs to, for example, create an instance of the most likely (e.g. highest
# likelihood) model of every fit to an image.

most_likely_model_parameters = list(
    map(lambda out: out.most_likely_model_parameters, non_linear_outputs)
)

print(most_likely_model_parameters)

# This creates a 1D Python list of all the model parameters. However, this isn't that much use. Afterall,
# which values correspond to which parameters? To find out, you'd have to directly compare to the files output on the
# hard-disk, which isn't ideal. However, we can instead create a model instance of every fit.

most_likely_model_instances = list(
    map(lambda out: out.most_likely_model_instance, non_linear_outputs)
)

print(most_likely_model_instances)

# This has created a list of 2 ModelInstance classes. A model instance uses the naming convention of the GalaxyModel in
# the pipeline to store the results.

# We can also access the 'most probable' model, which is the model computed by marginalizing over the MultiNest samples
# of every parameter in 1D and taking the median of this PDF.

most_probable_model_parameters = list(
    map(lambda out: out.most_probable_model_parameters, non_linear_outputs)
)
print(most_probable_model_parameters)

# This again produces a 1D Python list where it is difficult to know which parameters are which. Fortunately, we can
# create an equivalent ModelInstance of the most probable model.

most_probable_model_instances = list(
    map(lambda out: out.most_probable_model_instance, non_linear_outputs)
)

print(most_probable_model_instances)

#### BUG 3 - This no lonoger returns the model results successfully.

# We can load the results of all phases. The results are just a Python string that summarizes every fit's lens model.

# Other than printing this string for a quick inspection of all results, this doesn't offer too much utility, but it
# can be a handy way to quickly inspect all results.
results = aggregator.model_results(pipeline=pipeline_meta, phase=phase_name)

print(results)
